name: Build AI Top 10 Summary

on:
  schedule:
    - cron: "5 * * * *"     # hourly at :05 UTC (adjust if you like)
  workflow_dispatch:         # allow manual run

permissions:
  contents: write

concurrency:
  group: ai-summary
  cancel-in-progress: true

jobs:
  summarize:
    runs-on: ubuntu-latest

    steps:
      # Work directly on the published site branch
      - name: Checkout gh-pages
        uses: actions/checkout@v4
        with:
          ref: gh-pages
          fetch-depth: 0

      - name: Verify cache.json exists
        run: |
          test -f cache.json || { echo "::error ::cache.json not found on gh-pages"; exit 1; }

      - name: Setup Node 20
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Generate AI summary (Top 10) — robust shape handling
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          node - <<'NODE'
          import fs from 'node:fs/promises';

          // ---- Read & inspect cache.json ----
          const raw = await fs.readFile('cache.json', 'utf8').catch(()=>null);
          if (!raw) { throw new Error('cache.json not readable'); }

          let d;
          try { d = JSON.parse(raw); }
          catch (e) { throw new Error('cache.json JSON parse failed: ' + e.message); }

          const isArr = Array.isArray(d);
          const keys = !isArr && d && typeof d === 'object' ? Object.keys(d).slice(0,20) : [];
          console.log('[ai-summary] cache.json type:', isArr ? 'array' : typeof d, 'keys:', keys);

          // ---- Normalize to an array of entries ----
          function toArray(x) {
            if (Array.isArray(x)) return x;

            if (x && typeof x === 'object') {
              if (Array.isArray(x.items))   return x.items;
              if (Array.isArray(x.entries)) return x.entries;
              if (Array.isArray(x.data))    return x.data;
              if (x.feed && Array.isArray(x.feed.items)) return x.feed.items;
              if (x.items && typeof x.items === 'object') return Object.values(x.items);

              // Fallback: object values that look like feed entries
              return Object.values(x).filter(v =>
                v && typeof v === 'object' && (
                  'title' in v || 'link' in v || 'url' in v || 'published' in v || 'date' in v
                )
              );
            }
            return [];
          }

          const arr = toArray(d);
          console.log('[ai-summary] normalized entries:', arr.length);

          if (!arr.length) {
            const msg = '**Summary of Fantasy Impact (Top 10)**\\n\\nNo recent items found in cache.json.\\n';
            const generatedAt = new Date().toISOString();
            await fs.writeFile('top10.txt', msg + `\\nUpdated: ${generatedAt}\\n`, 'utf8');
            await fs.writeFile('top10.json', JSON.stringify({ generatedAt, items: [], summary: msg.trim() }, null, 2), 'utf8');
            console.log('[ai-summary] Wrote placeholders because no items were found.');
            process.exit(0);
          }

          // ---- Map to the fields we need ----
          const items = arr.map(it => ({
            title: it.title ?? 'Untitled',
            link: it.link || it.url || '',
            source: it.feedTitle || it.source || '',
            date: it.published || it.publishedAt || it.date || it.isoDate || it.createdAt || it.updated || null
          }))
          .sort((a,b) => new Date(b.date||0) - new Date(a.date||0))
          .slice(0, 10);

          console.log('[ai-summary] first titles:', items.slice(0,3).map(i => i.title));

          // ---- Build prompt ----
          const prompt = [
            "Summarize the fantasy football impact of these recent articles.",
            "Group bullets by themes: Injuries, Transactions, Depth/Usage, Waivers, Start/Sit.",
            "Be concise and actionable. End with 3 takeaways.",
            "Articles:",
            ...items.map((it, i) => `(${i+1}) ${it.title} — ${it.link}`)
          ].join("\\n");

          // ---- Call OpenAI (clear errors if any) ----
          if (!process.env.OPENAI_API_KEY) {
            throw new Error('Missing OPENAI_API_KEY secret.');
          }

          const resp = await fetch("https://api.openai.com/v1/responses", {
            method: "POST",
            headers: {
              "content-type": "application/json",
              "authorization": `Bearer ${process.env.OPENAI_API_KEY}`
            },
            body: JSON.stringify({
              model: "gpt-4.1-mini",
              input: prompt,
              temperature: 0.4
            })
          });

          const bodyText = await resp.text();
          if (!resp.ok) {
            console.error('[ai-summary] OpenAI error status:', resp.status, resp.statusText);
            console.error('[ai-summary] OpenAI body:', bodyText.slice(0, 1000));
            throw new Error('OpenAI request failed');
          }

          let data;
          try { data = JSON.parse(bodyText); }
          catch (e) { throw new Error('Failed to parse OpenAI JSON: ' + e.message); }

          const text = (data.output_text || "No summary returned.").trim();
          const generatedAt = new Date().toISOString();

          await fs.writeFile('top10.txt', text + `\\n\\nUpdated: ${generatedAt}\\n`, 'utf8');
          await fs.writeFile('top10.json', JSON.stringify({ generatedAt, items, summary: text }, null, 2), 'utf8');

          console.log("[ai-summary] Wrote top10.txt and top10.json");
          NODE

      - name: Commit & push
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add top10.txt top10.json || true
          git diff --cached --quiet || git commit -m "chore: update AI Top 10 summary [skip ci]"
          git push origin gh-pages
